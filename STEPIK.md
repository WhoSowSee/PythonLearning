Заключительный блок `else` в операторе `if-elif-else` является необязательным

---

Использование _a_ `in` вместо `or`

```python
a = int(input())

if a in (1, 3, 5, 7, 8, 10, 12):
    print(31)
elif a in (4, 6, 9, 11):
    print(30)
elif a == 2:
    print(28)

n, sum = int(input()), 0

for i in range(1, n + 1):
    if i // 2 % 10 in [2, 5, 8]:
        sum += i

print(sum)
```

---

В программировании для переменных цикла обычно используют буквы `i, j, k`

---

Бывают ситуации, когда переменная цикла не используется в теле цикла. В таком случае, вместо того, чтобы давать ей имя,
мы можем указать символ нижнего подчеркивания `_`:

```python
for _ in range(5):
    print('Python - awesome!')
```

Также `_` может использоваться при распаковке

---

Другая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор `continue` позволяет перейти к
следующей итерации цикла `for` или `while` до завершения всех команд в теле цикла.

Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78:

```python
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию

print(i)
```

---

Указанный в `else`, будет выполнен, когда штатным образом завершается цикл while или for

Если слово `else` отсутствует в описании цикла, то блок кода2 будет выполняться после завершения цикла, несмотря ни на
что. Если же слово `else` присутствует, то блок кода2 будет выполняться только в том случае, если цикл завершается
штатным образом. Под штатным завершением цикла подразумевается его завершение без использования оператора прерывания
break

```python
num = int(input())
n = num
flag = False

while n != 0:
    last = n % 10
    if last == 7:
        flag = True
        break  # прерываем цикл, так как число гарантированно содержит цифру 7
    n //= 10

if flag is True:
    print('Число', num, 'содержит цифру 7')
else:
    print('Число', num, 'не содержит цифру 7')
```

```python
num = int(input())
n = num

while n != 0:
    last = n % 10
    if last == 7:
        print('Число', num, 'содержит цифру 7')
        break
    n //= 10
else:
    print('Число', num, 'не содержит цифру 7')
```

---

**Примечание 1. Оператор `continue` не влияет на выполнение блока `else` в циклах**

**Примечание 2. Блок `else` в циклах часто применяется для обработки отсутствия элементов**

---

В цикле `while` вместо `or` используется `and` (по смыслу должно быть `or`)

---

Обратите внимание: если длина строки s равна `len(s)`, то при положительной нумерации слева направо, последний элемент
имеет индекс равный `len(s) - 1`, а при отрицательной индексации справа налево, первый элемент имеет индекс
равный `-len(s)`

---

## Методы

### Методы строк

• `isalpha(str)`: если строка в Python включает в себя лишь алфавитные символы, возвращается **True**;

• `islower(str)`: **True** возвращается, если строка включает лишь символы в нижнем регистре;

• `isupper(str)`: **True**, если символы строки в Python находятся в верхнем регистре;

• `startswith(str)`: **True**, когда строка начинается с подстроки _str_;

• `isdigit(str)`: **True**, когда каждый символ строки — цифра;

• `endswith(str)`: **True**, когда строка в Python заканчивается на подстроку _str_;

• `upper()`: строка переводится в верхний регистр;

• `lower()`: строка переводится в нижний регистр;

• `title()`: для перевода начальных символов всех слов в строке в верхний регистр;

• `capitalize()`: для перевода первой буквы самого первого слова строки в верхний регистр;

• `lstrip()`: из строки в Python удаляются начальные пробелы;

• `rstrip()`: из строки в Python удаляются конечные пробелы;

• `strip()`: из строки в Python удаляются и начальные, и конечные пробелы;

• `rjust(width)`: когда длина строки меньше, чем параметр `width`, слева добавляются пробелы, строка выравнивается по
правому краю;

• `ljust(width)`: когда длина строки в Python меньше, чем параметр `width`, справа от неё добавляются пробелы для
дополнения значения `width`, при этом происходит выравнивание строки по левому краю;

• `find(str,[start], [end])`: происходит возвращение индекса подстроки в строку в Python. В том случае, если подстрока
не найдена, выполняется возвращение числа **-1**;

• `center(width)`: когда длина строки в Python меньше, чем параметр `width`, слева и справа добавляются пробелы (
равномерно) для дополнения значения `width`, причём происходит выравнивание строки по центру;

• `split([delimeter[, num]])`: строку в Python разбиваем на подстроки в зависимости от разделителя;

• `replace(old, new[, num])`: в строке одна подстрока меняется на другую;

• `''.join(strs)`: строки объединяются в одну строку, между ними вставляется определённый разделитель.

---

### Методы списков

• `append()` добавляет новый элемент в конец списка;

• `extend()` расширяет один список другим списком;

• `insert()` вставляет значение в список в заданной позиции;

• `index()` возвращает индекс первого элемента, значение которого равняется переданному в метод значению;

• `remove()` удаляет первый элемент, значение которого равняется переданному в метод значению;

• `pop()` удаляет элемент по указанному индексу и возвращает его;

• `count()` возвращает количество элементов в списке, значения которых равны переданному в метод значению;

• `reverse()` инвертирует порядок следования значений в списке, то есть меняет его на противоположный;

• `copy() `создает поверхностную копию списка.;

• `clear()` удаляет все элементы из списка;

• оператор `del` позволяет удалять элементы списка по определенному индексу.

---

Пробелы, запятые и другие знаки входят в индексы

---

Индекс всегда меньше символа на единицу

---

Если мы хотим поменять какой-либо символ строки _s_, мы должны создать новую строку. Следующий код использует срезы и
решает поставленную задачу:

```python
s = 'abcdefghij'
s = s[:4] + 'X' + s[5:]
print(s)
```

Мы создаем два среза: от начала строки до 5-го символа (не включительно) и с 6-го символа (включительно) по конец
строки, а между ними вставляем нужный нам символ, который встанет на 5-ю позицию (4 индекс)

---

Возврат строк и списков в обратном порядке:

```python
a = 'abcd'
print(a[::-1])
```

---

Распаковать список (вывести все элементы списка в одну строку):

```python
a = [1, 2, 3, 4, 5]
print(*a)
```

---

Для того, чтобы создать список состоящий из 10 нулей мы можем использовать следующий код:

```python
zeros = [0] * 10
```

---

```python
numbers = []
for i in range(10):
    numbers.append(i)
```

В Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — **списочное
выражение** (_list comprehension_).

Предыдущий код можно записать следующим образом:

```python
numbers = [i for i in range(10)]
```

[выражение `for` переменная `in` последовательность]

где **переменная** — имя некоторой переменной, **последовательность** — последовательность значений, которые она
принимает (список, строка или объект, полученный при помощи функции `range`), **выражение** — некоторое выражение, как
правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка

---

Метод списков `sort` может принимать значение `key = функция` (например _int_). В связке с `input().split()` можно
элементы списка сразу сортировать в формате _int_ типа данных,а не _str_, и не делать отдельный цикл для этого.

Функции `max` и `min` также могут принимать аргумент `key = функция` (например _int_). В связке с `input().split()`
можно вывести максимальное или минимальное число в списке,не преобразовывая эти числа в _int_ с помощью отдельного
цикла `for`

---

```python
n = int(input())

list_str = list(range(n))
for i in range(n):
    list_str[i] = input()
```

Этот код тоже самое, что и:

```python
n = int(input())

list_str = []
for _ in range(n):
    user_str = input()
    list_str.append(user_str)
```

---

### Методы словарей

`keys()` - возвращает список ключей всех элементов словаря

`values()` - возвращает список значений всех элементов словаря

`items()` - возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение)

---

## Функции

**Примечание 1: Объявление функции должно предшествовать ее вызову**

**Примечание 2: Иногда, при объявлении функции требуется сделать своего рода заглушку, чтобы функция ничего не выполняла. Тогда мы используем ключевое слово `pass`:**

```python
def do_nothing():
    pass
```

В ходе исполнения оператора `pass` ничего не происходит, поэтому он может использоваться в качестве заглушки в тех
местах, где это синтаксически необходимо, например, в инструкциях, где тело является обязательным, таких как `def`.
Таким образом, оператор `pass` используется там, где код пока ещё не появился, но планируется

**Примечание 3: Результат вызова функции можно передавать в качестве аргумента этой же функции:**

```python
def sum_nums(a, b):
    return a + b


print(sum_nums(sum_nums(10, 5)), 30)
```

**Примечание 4: Функция в Python может иметь неизвестное заранее число параметров. Укажите `*` перед аргументом, если вы
не знаете, какое количество параметров передаст пользователь:**

```python
def welcome(*name_parts):
    message = 'Welcome, ' + name_parts[0] + " "
    message += name_parts[1] + " " + name_parts[2]
    print(message + "!")


welcome('Anton', 'Pavlovich', 'Chekhov')
```

**Аннотация типов** - указание типа данных для переменной (в случае функции - для параметра):

```python
def func(x: int, y: int):
    z = x + y
    return z


print(func(3, 5))
```

Также возможно задание в параметрах значения по умолчанию. В случае, если в функцию не будет передан аргумент,
автоматически будет подставлено это значение:

```python
def func(x: int = 10, y: int = 20):
    z = x + y
    return z


print(func())

```

Чтобы узнать какие существую аннотации в функции и какому из параметров они принадлежат можно использовать
метод `__annotations__`:

```python
def func(x: int, y: int):
    z = x + y
    return z


print(func(4, 3))
print(func.__annotations__)
```

Также в функции можно аннотировать то, что она возвращает (_return_):

```python
def func(x: int, y: int) -> int:
    z = x + y
    return z


print(func(4, 3))
print(func.__annotations__)

```

Чтобы аннотировать значения списка в функции, необходимо импортировать модуль typing (а именно тип `List` (с большой
буквы)). Указываем аннотацию для параметра - `List` и в квадратных скобочках указываем предполагаемый тип данных списка.

p.s После этого в функции будут предлагаться методы строк, что не происходило до указания типа данных значений списка

```python
from typing import List


def func(lst: List[str]):
    for elem in lst:
        print(elem.upper)
```

---

### Переменные функций

Разные функции могут иметь локальные переменные с одинаковыми именами, потому что они не видят локальных переменных друг
друга

Область действия переменной – часть программы, в которой можно к ней обращаться, та функция, где она создана. Переменная
видима только программному коду в области ее действия. Никакая инструкция за пределами функции не может обращаться к
такой переменной

К локальной переменной не может обращаться программный код, который появляется внутри функции до того, как переменная
была создана

Параметрическая переменная тоже локальная

Глобальными называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям

Функция может использовать любые глобальные переменные кроме имеющих те же имена, что и ее локальные переменные. Если в
функции объявлена локальная переменная с тем же именем, что у одной из глобальных, то данная глобальная переменная
становится недоступной в этой функции, и при указании идентификатора переменной произойдет обращение к локальной
переменной функции, а не одноименной глобальной

**Инструкция `global` в функции позволяет сделать локальную переменную (функции) глобальной (для всего файла):**

```python
def func(x, y):
    global z
    z = x + y


func(5, 7)
print(z)
```

---

### Функция с возвратом значения

Функция с возвратом значения возвращает значение обратно в ту часть программы, которая ее вызвала

Вот общий формат определения функции с возвратом значения в Python:

```python
def название_функции():
    блок
    кода
    return выражение
```

**Функция с возвратом значения завершается**

Рассмотрим ее работу. Первая инструкция в блоке функции присваивает значение `(5 / 9) * (temp - 32)`
переменной `result`. Затем исполняется инструкция `return`, которая приводит к завершению исполнения функции и
отправляет значение из переменной `result`, назад в ту часть программы, которая вызвала эту функцию

```python
# функция перевода градусов Фаренгейта в градусы Цельсия
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result


# основная программа
temp = float(input('Bвeдитe количество градусов по Фаренгейту: '))
celsius = convert_to_celsius(temp)
print(celsius)  # градусы Цельсия
```

В одной функции может быть сколько угодно инструкций return. Рассмотрим функцию convert_grade(), которая переводит
стобалльную оценку в пятибалльную:

```python
def convert_grade(grade):
    if grade >= 90:
        return 5
    elif grade >= 80:
        return 4
    elif grade >= 70:
        return 3
    elif grade >= 60:
        return 2
    else:
        return 1


# основная программа
grade = int(input('Введите вашу отметку по 100-балльной системе: '))
print(convert_grade(grade))
```

---

### Лямбда-функции

- Лямбда-функция аналогична функции `def`

- Лямбда-функция автоматически использует `return`, т.е указывать не надо

- Можно указывать все, что допустимо после `return`

- **Не стоит присваивать переменной _E731 pep8_**

- Не возвращает ошибку, если указанной переменной не существует

- Не выполняется до вызова `()`

- Не сохраняет в себе данные о переменных:

```python
x = 2
result = lambda: x ** 2

x = 3
result2 = lambda: x ** 2

print(result())  # 9
print(result2())  # 9
```

Чтобы это исправить, можно установить значение по умолчанию:

```python
x = 2
result = lambda n=x: n ** 2

x = 3
result2 = lambda n=x: n ** 2

print(result())  # 4
print(result2())  # 9
```

- Лямбда-функции можно использовать в качестве аргумента для функции `def`

---

## Встроенные функции

### Функция map

`map(func, \*iterables) -> map object`
_func_ - функция, которая будет применена к каждому элементу итерируемой последовательности. Функция указывается
без `()`
_iterables_ - итерируемая последовательность (список, кортеж)

Фактически, `map` заменяет цикл `for` и _генераторы_:

К `map-объекту` можно применять различные функции (len, max, min):

```python
m = map(int, ['1', '2', '3'])
s = sum(m)
print(s)  # 6
```

**Дважды пройтись по _коллекции_, которую возвращает `map` нельзя**

```python
m = map(int, ['1', '2', '3'])
s = sum(m)
s = sum(m)

print(s)  # 0
```

---

### Функция isinstance

Используется для проверки соответствия типа объекта какому-либо типу данных

```python
print(isinstance(3, int))  # True
print(isinstance('Beegeek', str))  # True
print(isinstance(True, bool))  # True
```

---

### Функция sum

Используется для вычисления суммы элементов итерируемого объекта, такого как список, кортеж или множество

```python
sum(iterable, start=0)
```

`iterable` - итерируемый объект (например, список, кортеж или множество), элементы которого будут суммироваться.

`start` - необязательный аргумент, который указывает начальное значение суммы. По умолчанию равен 0.

С помощью данной записи:

```python
sum(list, [])
```

можно конкатенировать списки (делать из вложенных списков один)

---

## Модули

**Примечание: Подключение модуля следующим образом: `from module import *` позволяет импортировать все функции в модуле
сразу и в дальнейшем не писать название модуля при вызове функций модуля**

### Модуль random

• Функция `shuffle()` принимает список в качестве обязательного аргумента и перемешивает его случайным образом

Следующий код перемешивает список numbers случайным образом, а затем выводит его содержимое

```python
import random

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
random.shuffle(numbers)
print(numbers)  # [4, 7, 8, 1, 2, 3, 6, 5]
```

• Функция `choice()` принимает список (строку) в качестве обязательного аргумента и возвращает один случайный элемент из
переданного списка (строки)

Следующий код выводит по одному случайному элементу из строки _'BEEGEEK'_ и списков _[1, 2, 3, 4], ['a', 'b', 'c', 'd']_

```python
import random

print(random.choice('BEEGEEK'))  # E
print(random.choice([1, 2, 3, 4]))  # 3
print(random.choice(['a', 'b', 'c', 'd']))  # c
```

• Функция `sample()` принимает два обязательных аргумента: список (строку) и количество случайных элементов, а
возвращает список случайных элементов в указанном количестве

```python
import random

numbers = [2, 5, 8, 9, 12]

print(random.sample(numbers, 1))  # [9]
print(random.sample(numbers, 2))  # [12, 5]
print(random.sample(numbers, 3))  # [9, 2, 8]
print(random.sample(numbers, 5))  # [12, 8, 9, 5, 2]
```

Количество случайных элементов не должно превышать длину начального списка (строки)

---

### Модуль decimal

```python
from decimal import Decimal

print(Decimal("0.1") + Decimal("0.1") + Decimal("0.1"))
```

---

`string.punctuation` — это одна из констант в модуле `string` в Python, которая содержит все наборы знаков препинания.
Например, используется для проверки `input()` на наличие спецсимволов. Для использования необходимо импортировать
модуль `string`

---

Большие числа можно записывать с символами подчёркивания: `a = 1_000_000_000`

---

## F-строки

Можно выводить большие числа с символами подчёркивания с помощью `f-строк`

```python
a = 1000000000
b = 2000
print(f"{a * b:_}")  # 2_000_000_000_000
```

С помощью `f-строк` можно выводить переменную со знаками по бокам

```python
num = 100
print(f'{num:&^20}')  # &&&&&&&&100&&&&&&&&&
print(f'{num:&<20}')  # 100&&&&&&&&&&&&&&&&&
print(f'{num:&>20}')  # &&&&&&&&&&&&&&&&&100
```

Если в `f-строке` в фигурных скобках указать `=`, то выведется и название переменной и ее значение

```python
a = 12

print(f'{a = }')  # a = 12
```

В `f-строках` также можно указывать и функции:

```python
def func():
    return 'text'


print(f'func() = {func()}')
print(f'{func() = }')
```

В `f-строках` можно указывать конкретное количество цифр после запятой в `float-типе данных`:

```python
a = 21.423

print(f'{a:.1f}')
```

---

C помощью функции `dir` можно вывести весь список методов для переменной

C помощью следующего кода можно вывести все встроенные функции в python:

```python
print(dir(__builtins__))
```

---

## Методы

Метод `enumerate` позволяет одновременно получать и индекс и значение (Работает быстрее чем len):

```python
numbers = [i for i in range(2, 100)]

for index, num in enumerate(numbers):
    n = num
    ind = index
    print(ind, n)
```

Используется вместо:

```python
for num in range(len(numbers)):
    n = numbers[num]
    ind = num
    print(ind, n)
```

Метод `zip` позволяет получать попарные элементы (получать элементы под одинаковыми индексами) со списков/кортежей/строк
и т.д до тех пор, пока самый короткий список/кортеж не закончится

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8, 9, 10]
z = zip(a, b)
for x in z:
    print(x)
```

Также, так как `zip-объект` является итератором, то его можно превратить в любую коллекцию:

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8]

res = zip(a, b)  # zip-объект
print(list(res))
```

Чтобы избежать работы с итераторами, можно сразу преобразовывать функцию `zip` (`zip-объект`) в список

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8]

res = list(zip(a, b))  # zip-объект
print(res)
```

Также, с помощью цикла `for` можно запоминать каждую пару значений:

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8]

for t1, t2 in zip(a, b):
    print(t1, t2)
```

С помощью функции `zip` также можно получить списки обратно:

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8, 9, 10]
c = "python"

res = zip(a, b, c)

coll1, coll2, coll3 = zip(*res)
print(coll1, coll2, "".join(coll3))
```

---

## Аннотация типов

**Аннотация типов** в Python позволяет передавать в переменную данные определенного типа (_ожидаемого типа_). То есть,
при указании другого типа данных интерпретатор все равно обработает код:

```python
a: int = 100
a = 'Hello'
print(a)  # Hello
```

Чтобы аннотировать значения переменной-списка/кортежа/словаря необходимо импортировать модуль `typing` (а именно
необходимый тип (с большой буквы)). Указываем аннотацию для переменной - и в квадратных скобочках указываем
предполагаемый тип данных.

```python
from typing import Dict

d: Dict[str, str] = {'name': 'John'}
print(d.__class__)
```

Импортируемый тип данных `Any` позволяет аннотировать переменной любой тип:

```python
from typing import Any

e: Any = 12
e = 'Hello'
```

Импортируемый тип данных `Optional` позволяет принимать переменной как и пустой тип данных - `None`, так и любой
другой (указывается в квадратных скобках):

```python
from typing import Optional

a: Optional[int] = None
a = 12
```

Импортируемый тип данных `Union` позволяет принимать переменной разные типы данных одновременно (т.е объединяет разные
типы данных):

```python
from typing import Union

a: Union[int, str, float] = 'Python'
a = 12
a = 1.4
```

Но в версиях Python >= 3.10 можно не использовать этот тип, а вместо него использовать знак `|`:

```python
a: int | str | float = 'Python'
a = 12
a = 1.4
```

---

Инструкция `if __name__ == '__main__'` используется для того, чтобы тело этой инструкции выполнялось только в данном
файле, и если данный файл импортируется в другой файл, то в нём не запускался код файла с `if __name__ == '__main__'`.
Также с помощью данной инструкции можно разделить код, который выполняется при запуске файла напрямую, и код, который
выполняется при импорте файла

---

## Словари

Словарь — реализация структуры данных `"ассоциативный массив"` или `"хеш таблица"`. В других языках аналогичная структура называется `map`, `HashMap`, `Dictionary`.

Словари, также как и списки являются изменяемыми объектами

Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — хеш-таблица. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.

---

_Ключом словаря могут быть данные любого неизменяемого типа:_

- число;
- строка;
- булево значение;
- кортеж;
- замороженное множество (frozenset);

_Значения могут относиться к любому типу данных, их тип данных произволен_

---

Если требуется вывести только ключи словаря, то мы так же можем использовать операцию распаковки словаря.

Приведенный ниже код:

```python
capitals = {"Россия": "Москва", "Франция": "Париж", "Чехия": "Прага"}

print(*capitals, sep="\n")
```

---

В качестве ключа можно указать выражение: Python вычислит его значение и обратится к искомому элементу:

```python
languages = {'Python': 'Гвидо ван Россум',
             'C#': 'Андерс Хейлсберг',
             'Java': 'Джеймс Гослинг',
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C' + '#'])  # Создателем языка C# является Андерс Хейлсберг
```

---

Если ключи словаря — строки без каких-либо специальных символов, то для создания словаря можно использовать функцию `dict()`

```python
info = dict(name='Timur', age=28, job='Teacher')
```

---

Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением

```python
info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей

info_dict = dict(info_list)  # создаем словарь на основе списка кортежей
```

---

Создать словарь на основании двух списков (кортежей) можно с помощью встроенной функции-упаковщика zip(), о которой расскажем позже.

Приведенный ниже код:

```python
keys = ['name', 'age', 'job']
values = ['Timur', 28, 'Teacher']

info = dict(zip(keys, values))

print(info)  # {'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```

---

Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом `fromkeys()`

```python
dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')
```

Если методу `fromkeys()` не передать второй параметр, то по умолчанию присваивается значение None

---

Для получения значения ключа используется следующая конструкция:

```python
my_dict = {'Password': 12345, 'Python': 'Best Programming Language'}

print(my_dict['Password'])  # 12345
```

---

Для удаления элементов используется тот же синтаксис, что и для списков `del`

---

Доступ к значению элемента можно получать через переменную:

```python
my_dict = {'Password': 12345, 'Python': 'Best Programming Language'}

key = 'Password'

print(my_dict[key])  # 12345
```

---

Значениями ключей могут быть другие словари:

```python
my_dict = {'Dict': {'Key': 123}}

print(my_dict['Dict']['Key'])  # 123
```

---

Для того, чтобы при получении несуществующего ключа выдавало не ошибку, а значение `None`, лучше использовать
метод `get`:

```python
my_dict = {'Password': 12345, 'Python': 'Best Programming Language'}

print(my_dict.get('Password'))  # 12345

print(my_dict.get('Login'))  # None
```

В метод `get` можно передавать значение по умолчанию, которое будет выводится, если ключ отсутствует:

---

```python
my_dict = {'Password': 12345, 'Python': 'Best Programming Language'}

print(my_dict.get('Login', 0))  # 0
```

---

Словарные методы `items()`, `keys()`, `values()` возвращают не совсем обычные списки. Типы этих списков – `dict_items`, `dict_keys`, `dict_values`, соответственно, в отличие от обычных списков `list`. Методы обычных списков недоступны для списков типа `dict_items`, `dict_keys`, `dict_values`. Используйте явное преобразование с помощью функции `list()` для получения доступа к методам списков.

---

## Конструкция match/case

Конструкцию `match/case` можно интерпретировать в качестве `if/else`
`match/case` позволяет анализировать шаблоны

```python
match < переменная >:
    case < шаблон_1 >:
    операторы
    case < шаблон_n >:
    операторы
    case _:
    иначе
```

```python
cmd = 'top'

match cmd:
    case 'top':
        print('Вверх')
    case 'bottom':
        print('Вниз')

# Вверх
```

В данном примере после каждого блока `case` указана некая _константа_. Как только значение `cmd` окажется равным одной
из констант, выполнится операторы соответствующего блока `case`

Как только один из блоков `case` отработал, на этом работа оператора `match` завершается:

```python
cmd = 'top'

match cmd:
    case 'top':
        print('Вверх')
    case 'top':
        print('Вниз')

# Вверх
```

Если в блоке `case` нужно учесть сразу несколько _констант_, это можно сделать через оператор `|`:

```python
cmd = 'right'

match cmd:
    case 'top' | 'right':
        print('Вверх, Вправо')
    case 'bottom':
        print('Вниз')

# Вверх, Вправо
```

Если указать в блоке `case` в качестве _константы_ `_`, то в в случае если ни один другой `case` не сработает, то будут
выведены операторы `case _:`:

```python
cmd = 'left'

match cmd:
    case 'top':
        print('Вверх')
    case 'bottom':
        print('Вниз')
    case _:
        print('Другое')

# Другое
```

Если в `case` вместо конкретной _константы_ указать переменную (возможно, даже еще не существующую), то произойдет
присвоение этой переменной значения шаблона:

```python
cmd = 'left'

match cmd:
    case command:  # command = cmd
        print(f'Команда: {command}')

# left
```

Данный блок `case` будет выполнятся в любом случае, то есть все последующие блоки `case` не смогут выполнится в любом
случае => (**SyntaxError**)

---

## Типы данных

### Bool

- **Приоритет оператора not выше, чем у оператора and, приоритет которого, в свою очередь, выше, чем у оператора or**
- **К логическим значениям можно применять арифметические операции (+, -, \*...)**

С помощью сложения логических значений вместе, можно подсчитывать количество значений `True`. Это может пригодиться,
когда требуется подсчитать количество элементов, удовлетворяющих условию:

```python
numbers = [1, 2, 3, 4, ** ** ** 5 **, 8, 10, 12, 15, 17]
res = 0

for num in numbers:
    res += (num % 2 == 0)

print(res)  # 5
```

- строки: пустая строка — `False`, непустая строка — `True`;
- числа: нулевое число — `False`, ненулевое число (в том числе и меньшее нуля) — `True`;
- списки: пустой список — `False`, непустой — `True`.

Мы можем создавать функции, возвращающие булевы значения (True или False)
В программировании функция, которая возвращает значение True или False, называется **предикатом**

---

### Nonetype

Концепция `None` заключается в том, что оно дает переменной нейтральное или "нулевое" поведение

Все переменные, которым присвоено значение None, ссылаются на один и тот же объект типа NoneType. Создание собственных
экземпляров типа NoneType недопустимо. Объекты, существующие в единственном экземпляре, называются **синглтонами**

---

### String

Строки сравниваются в соответствии с лексикографическим порядком. В таблице символов сначала идут заглавные буквы (A, B,
C, ..., Z), затем строчные (a, b, c, ..., z). Таким образом, строка, начинающаяся на z самая большая

---

## Списки

Когда вы создаете список `list1`, содержащий вложенные списки `[1, 2, 3] и [4, 5]`, и затем присваиваете
переменной `list2` значение `list1`, обе переменные начинают ссылаться на один и тот же объект списка в памяти. Это
означает, что `list1` и `list2` указывают на один и тот же список, а не на разные копии.

Когда вы изменяете вложенный список, например, добавляя элемент 7 по индексу 0` (list1[0].append(7))`, это изменение
отражается в самом объекте списка, на который указывают как `list1`, так и `list2`, так как они оба ссылаются на один и
тот же объект в памяти.

Чтобы создать независимую копию списка, включая все вложенные списки, вы можете использовать модуль `copy` и
функцию `deepcopy`. Этот подход создает новые объекты для каждого элемента, включая вложенные списки, что позволяет
избежать таких изменений:

```python
import copy

list1 = [[1, 2, 3], [4, 5]]
list2 = copy.deepcopy(list1)

list1[0].append(7)

print(list1)  # [[1, 2, 3, 7], [4, 5]]
print(list2)  # [[1, 2, 3], [4, 5]]
```

Таким образом, глубокое копирование создает полноценные независимые копии списков, и изменения в одной копии не влияют
на другую.

### Вложенные списки

Вложенные списки обычно называют **двумерными списками**

При использовании во вложенных списках функций `min()`, `max()` элементы вложенных списков должны быть сравнимы.

```python
my_list = [[1, 7, 12, 0, 9, 100], ['a', 'b']]

print(min(my_list))
print(max(my_list))

# TypeError: '<' not supported between instances of 'str' and 'int'
```

Функции `min()` и `max() `могут работать и со списками. Если этим функциям передается несколько списков, то целиком
возвращается один из переданных списков. При этом сравнение происходит поэлементно: сначала сравниваются первые элементы
списков. Если они не равны, то функция `min()` вернет тот список, первый элемент которого меньше, `max() `– наоборот.
Если первые элементы равны, то будут сравниваться вторые и т. д.

---

Кортежи

**Примечание:** Списки предназначены для объединения неопределенного количества однородных сущностей. Кортежи, как
правило, объединяют под одним именем несколько разнородных объектов, имеющих различный смысл.

## Множества

Если два множества _X_ и _Y_ состоят из одних и тех же элементов, то они называются равными _X_ = _Y_.
